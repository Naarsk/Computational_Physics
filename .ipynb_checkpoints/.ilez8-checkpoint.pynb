{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 1. Random numbers with gaussian distribution:\n",
    "Metropolis algorithm\n",
    "Here we use the Metropolis algorithm to generate points with the distribution\n",
    "P(x) = exp(-x^2/2s^2). We consider s = 1, but the suggestion\n",
    "is to write the code for a generic s."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "(a) Start from x0=0 and choose d=5s to be the maximum displacement\n",
    "for each step. Execute runs with n=100, 1000, 10000, 100000 points,\n",
    "make an histogram of the points generated and compare it with the\n",
    "gaussian distribution. For which n the agreement is satisfactory?"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import numpy as np\n",
    "\n",
    "def metropolis(p,x0,d,n):\n",
    "    x=[]\n",
    "    xi=x0\n",
    "    for i in range(n):\n",
    "        x.append(xi)\n",
    "        di=np.random.uniform(-d,d)\n",
    "        xt=xi+di\n",
    "        w=p(xt)/p(xi)\n",
    "        if w >= 1:\n",
    "            xi=xt\n",
    "        else:\n",
    "            r=np.random.uniform(0,1)\n",
    "            if w >= r:\n",
    "                xi=xt   \n",
    "    return x"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "def p(x):\n",
    "    s=1\n",
    "    return np.exp(-x**2/(2*s**2))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import matplotlib.pyplot as plt\n",
    "lst=metropolis(p,0,5,n)\n",
    "nbins=15\n",
    "n=10000\n",
    "\n",
    "#histogram\n",
    "plt.hist(lst, bins=nbins, range=(-4,4), density=True)\n",
    "#function\n",
    "x = np.linspace(-4,4,100)\n",
    "y = p(x)/np.sqrt(2*np.pi)\n",
    "plt.plot(x,y, 'r')\n",
    "\n",
    "\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "#Tenendo fissato a 16 il numero di bins in cui ho diviso l'intervallo [-4,4], \n",
    "#per n crescenti ho calcolato Sn, la somma in quadratura delle differenze \n",
    "#tra il valore dell'istogramma normalizzato in ogni bin e il valore teorico \n",
    "#della distribuzione (normalizzata) al centro del bin. Ho ripetuto per alcuni valori di n.\n",
    "nbins=16\n",
    "kmax=11\n",
    "n=512\n",
    "S=[]\n",
    "nlst=[]\n",
    "\n",
    "for k in range(kmax):\n",
    "    lst=metropolis(p,0,5,n)\n",
    "    hist, bin_edges = np.histogram(lst, bins=nbins, range=(-4,4), density=True)\n",
    "    bin_centers = (bin_edges[:-1] + bin_edges[1:]) / 2.\n",
    "    y=p(bin_centers)/np.sqrt(2*np.pi)\n",
    "    S.append(sum((hist-y)**2)/nbins)\n",
    "    nlst.append(n)\n",
    "    n=n*2"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import matplotlib.pyplot as plt\n",
    "import numpy as np\n",
    "\n",
    "#loglog plot\n",
    "plt.plot(np.log2(nlst), np.log2(S))\n",
    "\n",
    "plt.xlabel('log n')\n",
    "plt.ylabel('log S')\n",
    "plt.title(str(nbins)+' bins')\n",
    "\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "#least squares fit\n",
    "import numpy as np\n",
    "\n",
    "def lsfit(x,y):\n",
    "    if len(x)== len(y):\n",
    "        n=len(x)\n",
    "    else:\n",
    "        print('error: array lenghts do not match')\n",
    "        \n",
    "    x=np.array(x)\n",
    "    y=np.array(y)\n",
    "    \n",
    "    xm=sum(x)/n\n",
    "    ym=sum(y)/n\n",
    "    \n",
    "    ssxx=sum(x**2)-n*xm**2\n",
    "    ssxy=sum(x*y)-n*xm*ym\n",
    "\n",
    "    m=ssxy/ssxx\n",
    "    q=ym-m*xm\n",
    "    \n",
    "    return(m,q)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "m,q=lsfit(np.log(nlst), np.log(S))\n",
    "\n",
    "print('m_unif=', m)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "(b) Choose n which gives a satisfactory result. For s fixed, change the\n",
    "step size d (i.e., change the ratio d/s). Determine qualitatively the\n",
    "dependence of the acceptance ratio on d/s. Make a plot. How to\n",
    "choose d/s in order to accept from ⇡ 1/3 to ⇡ 1/2 of trial changes?"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "def na_metropolis(p,x0,d,n):\n",
    "    na=0\n",
    "    xi=x0\n",
    "    for i in range(n):\n",
    "        di=np.random.uniform(-d,d)\n",
    "        xt=xi+di\n",
    "        w=p(xt)/p(xi)\n",
    "        if w >= 1:\n",
    "            xi=xt\n",
    "        else:\n",
    "            r=np.random.uniform(0,1)\n",
    "            if w >= r:\n",
    "                xi=xt   \n",
    "                na=na+1\n",
    "    return na"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "n=10000\n",
    "dvalues=[10,5,2,1,0.5,0.2,0.1, 0.01]\n",
    "lst=[]\n",
    "\n",
    "for d in dvalues:\n",
    "    lst.append(na_metropolis(p,0,d,n)/n)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "print(lst)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import matplotlib.pyplot as plt\n",
    "import numpy as np\n",
    "\n",
    "#loglog plot\n",
    "plt.plot(dvalues,lst)\n",
    "\n",
    "plt.xlabel('d/s')\n",
    "plt.ylabel('n_a/n')\n",
    "plt.title('acceptance ratio')\n",
    "\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "(c) By varying n in a more refined way (e.g. from 100 to 10000 with steps\n",
    "of 100), compare the first moments of the distribution obtained numerically\n",
    "with the exact ones analytically calculated with the Gaussian.\n",
    "In particular, focus on the second moment and make a plot of\n",
    "the di↵erence “exact variance - numerical variance” as a function of\n",
    "n."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import numpy as np\n",
    "nmax=2*10**4\n",
    "D=[]\n",
    "nlst=[]\n",
    "\n",
    "for n in range(100,nmax,100):\n",
    "    x=metropolis(p,0,5,n)\n",
    "    s=np.var(x,ddof=1)        #unbiased estimator\n",
    "    D.append(abs(s-1))\n",
    "    nlst.append(n)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import matplotlib.pyplot as plt\n",
    "import numpy as np\n",
    "\n",
    "#loglog plot\n",
    "plt.plot(nlst,D)\n",
    "\n",
    "plt.xlabel('n')\n",
    "plt.ylabel('Dn')\n",
    "plt.title('|exact variance - numerical variance|')\n",
    "\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "(d) For fixed s = 1 and d=5s, determine qualitatively the equilibration\n",
    "time (i.e. the number of steps necessary to equilibrate the system);\n",
    "a possible criterion is that the numerical estimate of <x^2>-< x>^2 is close enough to s^2, say within 5%."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 2. Sampling physical quantities: direct sampling and Metropolis sampling\n",
    "Consider the quantum harmonic oscillator and its ground state. The exact\n",
    "solution and the expectation values of kinetic, potential and total energy\n",
    "are know analitically, and can be used to compare the numerical results."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "(a) Direct sampling. Estimate kinetic energy, potential energy, first moments\n",
    "<x^i> of the wave function f(x) = Ae^(-x^2/4s^2) with a samplemean\n",
    "Monte Carlo calculation of the integral of the expectation values\n",
    "using a sequence of random points directly obtained for instance\n",
    "from the gasdev subroutine (see Lecture III).                                    Study the numerical accuracy and the convergence of the previous quantities as a function of the number of sampling points (since variance and kinetic, potential and total energy depend on the second moment <x^2>, you should find the same behavior for all these quantities, a part from a scaling factor)."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import numpy as np\n",
    "def boxmuller(m,s):\n",
    "    v1,v2=np.random.uniform(0,1,2)\n",
    "    r=np.sqrt(-2*np.log(v1))\n",
    "    x=r*np.cos(2*np.pi*v2)*s+m\n",
    "    y=r*np.sin(2*np.pi*v2)*s+m\n",
    "    return x,y"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import numpy as np\n",
    "n=10000\n",
    "s=1\n",
    "x=0\n",
    "x2=0\n",
    "\n",
    "for i in range(int(n/2)):\n",
    "    a,b=boxmuller(0,s)\n",
    "    x=x+a+b\n",
    "    x2=x2+a**2+b**2\n",
    "    \n",
    "x=x/n\n",
    "x2=x2/n\n",
    "\n",
    "Epot=x2/2\n",
    "Ekin=1/(4*s**2)-x2/(8*s**4)\n",
    "print(Epot,Ekin)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "(c) Metropolis sampling. Repeat the sampling using the Metropolis algorithm.\n",
    "See for instance the code metropolis sampling.f90. Evaluate\n",
    "the numerical accuracy and convergence of the more relevant\n",
    "quantities as a function of the number of sampling points. (see the\n",
    "comment in (a))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "n=10000\n",
    "\n",
    "def p(x):\n",
    "    s=1\n",
    "    return np.exp(-x**2/(2*s**2))\n",
    "\n",
    "x=metropolis(p,0,5,n)\n",
    "Epot=sum(np.array(x)**2)/(2*n)\n",
    "Ekin=(2*s**2-sum(np.array(x)**2)/n)/(8*s**4)\n",
    "print(Epot,Ekin)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "s=1\n",
    "kmax=11\n",
    "n=2**9\n",
    "Em=[]\n",
    "Ed=[]\n",
    "nlst=[]\n",
    "Etot=s**2/2+1/(8*s**2)\n",
    "for k in range(kmax):\n",
    "    #direct\n",
    "    for i in range(int(n/2)):\n",
    "        a,b=boxmuller(0,s)\n",
    "        x2=x2+a**2+b**2\n",
    "    x2=x2/n\n",
    "    Etotd=x2/2+1/(4*s**2)-x2/(8*s**4)\n",
    "    Ed.append(abs(Etotd-Etot))\n",
    "    #metropolis\n",
    "    x=metropolis(p,0,5,n)\n",
    "    Etotm=sum(np.array(x)**2)/(2*n)+(2*s**2-sum(np.array(x)**2)/n)/(8*s**4)\n",
    "    Em.append(abs(Etotm-Etot))\n",
    "    n=n*2\n",
    "    nlst.append(n)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import matplotlib.pyplot as plt\n",
    "import numpy as np\n",
    "\n",
    "#loglog plot\n",
    "plt.plot(np.log2(nlst),np.log2(Ed), label='direct')\n",
    "plt.plot(np.log2(nlst),np.log2(Em), label='metropolis')\n",
    "\n",
    "plt.xlabel('log n')\n",
    "plt.ylabel('log DE')\n",
    "plt.title('Error on total energy')\n",
    "plt.legend()\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "md,qd=lsfit(np.log2(nlst),np.log2(Ed))\n",
    "mm,qm=lsfit(np.log2(nlst),np.log2(Em))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "print(md,mm)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "print(md,mm)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "print(md,mm)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 3. Correlations"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "(a) Calculate the autocorrelation function C(j) = hxixi+ji hx2i\n",
    "i \n",
    "for a\n",
    "sequence or random numbers distributed according to a gaussian using\n",
    "the Metropolis method, testing di↵erent values of \"/!. Comment\n",
    "the results."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import numpy as np\n",
    "def autocorrelation(x):\n",
    "    n=len(x)\n",
    "    C=np.empty(n)\n",
    "    for j in range(n):\n",
    "        cx=0\n",
    "        for i in range(0,n):\n",
    "            cx=cx+x[i]*x[(i+j)%n]\n",
    "        cx=cx/n\n",
    "        C[j]=(cx-np.mean(x)**2)/(np.var(x)-np.mean(x)**2)\n",
    "    return C\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "n=100\n",
    "dvalues=[5,2,1,0.5,0.2,0.1]\n",
    "lst=[]\n",
    "\n",
    "for d in dvalues:\n",
    "    x=metropolis(p,0,d,n)\n",
    "    C=autocorrelation(x)\n",
    "    lst.append(C)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import matplotlib.pyplot as plt\n",
    "import numpy as np\n",
    "\n",
    "#loglog plot\n",
    "for j in range(len(dvalues)):\n",
    "    plt.plot(range(100),lst[j][0:100],'p', label='d/s=' + str(dvalues[j]))\n",
    "\n",
    "plt.xlabel('n')\n",
    "plt.ylabel('C')\n",
    "plt.title('Autocorrelation function')\n",
    "plt.legend()\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "n=100\n",
    "d=1\n",
    "s=1\n",
    "x=[]\n",
    "#direct\n",
    "for i in range(int(n/2)):\n",
    "    a,b=boxmuller(0,s)\n",
    "    x.append(a)\n",
    "    x.append(b)\n",
    "Cd=autocorrelation(x)\n",
    "#metropolis\n",
    "x=metropolis(p,0,5,n)\n",
    "Cm=autocorrelation(x)\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import matplotlib.pyplot as plt\n",
    "import numpy as np\n",
    "\n",
    "#loglog plot\n",
    "plt.plot(range(n),Cd,'p', label='direct')\n",
    "plt.plot(range(n),Cm,'p', label='metropolis')\n",
    "\n",
    "\n",
    "plt.xlabel('n')\n",
    "plt.ylabel('C')\n",
    "plt.title('Autocorrelation function')\n",
    "plt.legend()\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 4. Verification of the Boltzmann distribution\n",
    "We can verify directly that the Metropolis algorithm yields the Boltzmann\n",
    "distribution. We consider a single classical particle in one dimension\n",
    "in equilibrium with a heath bath (canonical ensemble). We fix therefore\n",
    "the temperature T, which labels a macrostate. The energy E can vary\n",
    "according to the particular microstate (in this particular case, it is enough\n",
    "to label a microstate, a part from the sign of the velocity)."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "(a) Write a code (see e.g. boltzmann metropolis.f90) to determine\n",
    "the form of the probability distribution P(E) that is generated by\n",
    "the Metropolis algorithm. Let for instance T=1, the initial velocity\n",
    "vinitial=0, the number of Monte Carlo steps nmcs=1000, and the\n",
    "maximum variation of the velocity dvmax=2. Calculate the mean\n",
    "energy, the mean velocity, and the probability density P(E)."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import numpy as np\n",
    "\n",
    "def metropolis_bz(b,n):\n",
    "    v=0              #initial microstate\n",
    "    E=0           \n",
    "    \n",
    "    na=0\n",
    "    vlst=[]\n",
    "    Elst=[]\n",
    "    dvmax=10\n",
    "    \n",
    "    for i in range(n):\n",
    "        vlst.append(v)\n",
    "        Elst.append(E)\n",
    "        \n",
    "        dv=dvmax*np.random.uniform(-1,1)       #random variation\n",
    "        vt=v+dv\n",
    "        de= 0.5*(vt**2 - v**2)\n",
    "        if de <= 0:                            #accept\n",
    "            v=vt\n",
    "            na=na+1\n",
    "            E=E+de\n",
    "        else:\n",
    "            rnd=np.random.uniform(0,1)\n",
    "            if np.exp(-b*de)>=rnd:             #accept\n",
    "                v=vt\n",
    "                na=na+1\n",
    "                E=E+de   \n",
    "    return vlst, Elst, na"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "n=10000\n",
    "b=10\n",
    "vlst, Elst, na = metropolis_bz(b,n)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import matplotlib.pyplot as plt\n",
    "import numpy as np\n",
    "\n",
    "A = 4/np.sqrt(b)\n",
    "\n",
    "#histogram\n",
    "plt.hist(vlst,range=(-A,A), bins=35, density=True)\n",
    "\n",
    "x=np.linspace(-A,A,100)\n",
    "y=np.sqrt(b/(np.pi*2))*np.exp(-b*x**2/2)\n",
    "plt.plot(x,y)\n",
    "\n",
    "plt.xlabel('v')\n",
    "plt.ylabel('f(v)')\n",
    "plt.title('1D - beta=1')\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import matplotlib.pyplot as plt\n",
    "import numpy as np\n",
    "#from matplotlib import rc\n",
    "#rc('text', usetex=True) \n",
    "\n",
    "\n",
    "A=4/b\n",
    "#histogram\n",
    "plt.hist(Elst, range=(0,A), bins=35, density=True)\n",
    "\n",
    "x=np.linspace(0,A,100)\n",
    "y=np.sqrt(b/(np.pi*x))*np.exp(-b*x)\n",
    "#y=1.78*np.sqrt(1/(x+0.5))*np.exp(-(x+0.5))\n",
    "\n",
    "plt.plot(x,y)\n",
    "#plt.plot(x,y, label = r'$\\frac{{1.78}\\,  e^{-(E+0.5)}}{\\sqrt{E+0.5}}  $')\n",
    "\n",
    "plt.xlabel('E')\n",
    "plt.ylabel('P(E)')\n",
    "plt.title('1D - beta=1')\n",
    "plt.legend()\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import matplotlib.pyplot as plt\n",
    "import numpy as np\n",
    "A=4/b\n",
    "#histogram\n",
    "hist, bin_edges =np.histogram(Elst, range=(0,A), bins=35, density=True)\n",
    "x=(bin_edges[1:]+bin_edges[:-1])/2\n",
    "y=np.log(hist)\n",
    "plt.plot(x,y, label='log hist')\n",
    "\n",
    "m,q=lsfit(x[5:30],y[5:30])\n",
    "print('m=', m)\n",
    "xl=np.linspace(0,4,5)\n",
    "yl=m*xl+q\n",
    "plt.plot(xl,yl,label=str(np.round(m,2))+'E' +str(np.round(q,2)))\n",
    "\n",
    "plt.xlabel('E')\n",
    "plt.ylabel('log P(E)')\n",
    "\n",
    "plt.legend()\n",
    "plt.show()\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "vm=np.mean(vlst)\n",
    "ve=np.mean(Elst)\n",
    "print(vm,ve)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "(e) Modify the program to simulate an ideal gas of N particles in one\n",
    "dimension. [Hint: modify the subroutine Metropolis inserting a loop\n",
    "over the particles] Consider for instance N=20, T=100, nmcs=200.\n",
    "Assume all particles to have the same initial velocity vinitial=10.\n",
    "Determine the value of dvmax so that the acceptance ratio is about\n",
    "50% ? What are the mean energy hEi (i.e., total energy of the system\n",
    "hEtoti divided by the number of particles) and the mean velocity?\n",
    "[the symbol hi indicates temporal(statistical) averages]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [],
   "source": [
    "import numpy as np\n",
    "\n",
    "def metropolis_bz_N(b,n,N):\n",
    "    v0=0\n",
    "    \n",
    "    v=np.zeros(N)+v0             #initial microstate\n",
    "    E=0           \n",
    "    \n",
    "    na=0\n",
    "    varr=np.empty((N,n))\n",
    "    Elst=[]\n",
    "    dvmax=0.15\n",
    "    \n",
    "    for i in range(n):\n",
    "        varr[:,i]=v\n",
    "        Elst.append(E/N)\n",
    "        \n",
    "        dv=dvmax*np.random.uniform(-1,1,N)       #random variation\n",
    "        vt=v+dv\n",
    "        de= 0.5*sum(vt**2 - v**2)\n",
    "        if de <= 0:                            #accept\n",
    "            v=vt\n",
    "            na=na+1\n",
    "            E=E+de\n",
    "        else:\n",
    "            rnd=np.random.uniform(0,1)\n",
    "            if np.exp(-b*de)>=rnd:             #accept\n",
    "                v=vt\n",
    "                na=na+1\n",
    "                E=E+de   \n",
    "    return varr, Elst, na"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "n=10000\n",
    "N=200\n",
    "b=1\n",
    "varr, Elst, na=metropolis_bz_N(b,n,N)\n",
    "\n",
    "vm = np.sum(varr, 1)/N\n",
    "\n",
    "print(na/n)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import matplotlib.pyplot as plt\n",
    "import numpy as np\n",
    "\n",
    "\n",
    "\n",
    "#histogram\n",
    "plt.hist(vm, bins=15, density=True)\n",
    "\n",
    "\n",
    "plt.xlabel('v')\n",
    "plt.ylabel(r'$\\langle f(v)\\rangle$')\n",
    "plt.title('N='+str(N))\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import matplotlib.pyplot as plt\n",
    "import numpy as np\n",
    "#from matplotlib import rc\n",
    "#rc('text', usetex=True) \n",
    "\n",
    "m = np.mean(Elst)\n",
    "s = np.sqrt(np.var(Elst, ddof=1))\n",
    "\n",
    "A=4/b\n",
    "#histogram\n",
    "plt.hist(Elst, range=(m-4*s,m+4*s), bins=25, density=True)\n",
    "\n",
    "\n",
    "x=np.linspace(m-4*s,m+4*s,100)\n",
    "y=1/(s*np.sqrt(np.pi*2))*np.exp(-(x-m)**2/(2*s**2))\n",
    "plt.plot(x,y)\n",
    "\n",
    "\n",
    "\n",
    "plt.xlabel('E')\n",
    "plt.ylabel('P(E)')\n",
    "plt.title('N='+str(N))\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import matplotlib.pyplot as plt\n",
    "import numpy as np\n",
    "\n",
    "#histogram\n",
    "plt.hist(Elst, bins=35, density=True)\n",
    "\n",
    "\n",
    "plt.xlabel('E')\n",
    "plt.ylabel('P(E)')\n",
    "plt.title('N='+str(N))\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {},
   "outputs": [],
   "source": [
    "n=10000\n",
    "N=200\n",
    "blst=np.array(range(1,101))/20.0\n",
    "m=[]\n",
    "\n",
    "for b in blst:\n",
    "    varr, Elst, na=metropolis_bz_N(b,n,N)\n",
    "    m.append(np.mean(Elst))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "199\n"
     ]
    }
   ],
   "source": [
    "print(len(m))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {},
   "outputs": [],
   "source": [
    "y=[]\n",
    "x=[]\n",
    "for i in range(1,len(blst)):\n",
    "    d=(m[i]-m[i-1])/(blst[i]-blst[i-1])\n",
    "    bm=(blst[i]+blst[i-1])/2\n",
    "    y.append(-d*bm**2)\n",
    "    x.append(bm)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 27,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 432x288 with 1 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "import matplotlib.pyplot as plt\n",
    "import numpy as np\n",
    "\n",
    "#capacity\n",
    "plt.plot(x[:100],y[:100], label=r'$-\\beta^2 \\frac{\\partial \\langle E\\rangle }{\\partial \\beta}$')\n",
    "xc=np.linspace(0,5,5)\n",
    "yc=0.48*np.ones(len(xc))\n",
    "plt.plot(xc,yc, label='0.48')\n",
    "\n",
    "plt.xlabel(r'$\\beta$')\n",
    "plt.ylabel(r'$\\frac{C}{Nk_B}$')\n",
    "plt.legend()\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 18,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "0.48220431742927156"
      ]
     },
     "execution_count": 18,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "np.mean(y[:100])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 28,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 432x288 with 1 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "import matplotlib.pyplot as plt\n",
    "import numpy as np\n",
    "\n",
    "#capacity\n",
    "plt.hist(y, range=(-2,3), bins= 7)\n",
    "\n",
    "\n",
    "plt.xlabel(r'$\\frac{C}{Nk_B}$')\n",
    "plt.ylabel('counts')\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 52,
   "metadata": {},
   "outputs": [],
   "source": [
    "n=10000\n",
    "N=200\n",
    "b=1\n",
    "varr, Elst, na=metropolis_bz_N(b,n,N)\n",
    "s21=np.var(Elst,ddof=1)\n",
    "C1=s21*b**2\n",
    "varr, Elst, na=metropolis_bz_N(b,n,N)\n",
    "b=0.01\n",
    "s201=np.var(Elst,ddof=1)\n",
    "C01=s201*b**2\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 53,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "0.004125131497088244 5.612014525448624e-07\n"
     ]
    }
   ],
   "source": [
    "print(C1,C01)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 56,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "96.0 165.00525988352973\n"
     ]
    }
   ],
   "source": [
    "k=1.4 *10**(-23)\n",
    "print(0.48*N, C1*N**2)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
